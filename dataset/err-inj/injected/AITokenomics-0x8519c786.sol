// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/*
    ---------------------------------------------------------------------------------------
    AI-GENERATED SMART CONTRACT
    
    This smart contract has been generated by an AI model and features innovative tokenomics
    designed to promote healthy growth for the project. Please note that this is an AI-powered
    experiment, and nobody is responsible for how the contract may behave.
    
    Purpose of the Experiment:
    --------------------------
    The experiment aims to evaluate the effectiveness of AI-generated tokenomics in fostering
    a community-driven, decentralized financial ecosystem. The contract features dynamic tax
    mechanisms, designed to disincentivize frequent selling and encourage long-term holding.
    
    Special Tokenomics:
    -------------------
    1. Buy launch tax: 20%
    2. Sell launch tax: 20%
    3. Final tax after 2 minutes: 2% for both buy and sell
    4. Three consecutive sells trigger a 50% sell tax, which goes to the liquidity pool.
    5. Three consecutive buys of at least 1000 tokens reset the tax to normal levels.
    
    Benefits:
    ---------
    1. Encourages long-term holding
    2. Punishes frequent selling
    3. Fosters a healthier liquidity pool
    4. Rewards early adopters and genuine supporters
    
    ---------------------------------------------------------------------------------------
*/

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

contract AITokenomics is IERC20 {
    string public constant name = "AI TOKENOMICS";
    string public constant symbol = "AIT";
    uint8 public constant decimals = 18;
    uint256 private _totalSupply = 1000000 * 10 ** uint256(decimals);
    address public owner;
    uint256 public launchTime;
    bool public tradingEnabled = false;
    
    uint256 public buyTax = 20;  // 20%
    uint256 public sellTax = 20; // 20%
    uint256 public finalTax = 2; // 2%
    uint256 public consecutiveSells = 0;
    uint256 public consecutiveBuys = 0;
    uint256 public totalBuysAtLaunch = 0;
    
    uint256 public maxWalletSize = (_totalSupply * 2) / 100;  // 2% of total supply
    uint256 public maxTransactionSize = (_totalSupply * 2) / 100;  // 2% of total supply

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    
    constructor() {
        owner = msg.sender;
        _balances[owner] = _totalSupply;
    }

    function startTrading() external {
        require(msg.sender == owner, "Only the owner can enable trading");
        require(!tradingEnabled, "Trading is already enabled");
        tradingEnabled = true;
        launchTime = block.timestamp;
    }

    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }
    
    
    function transfer(address recipient, uint256 amount) public override returns (bool) {
        require(tradingEnabled || msg.sender == owner, "Trading is not enabled yet");
        
        if (msg.sender != owner && recipient != owner && totalBuysAtLaunch < 30) {
            require(_balances[recipient] + amount <= maxWalletSize, "Exceeds maximum wallet size");
            require(amount <= maxTransactionSize, "Exceeds maximum transaction size");
        }
        
        bool isBuy = recipient == owner; 
        bool isSell = msg.sender == owner;

        if (isBuy && block.timestamp - launchTime <= 2 minutes) {
            totalBuysAtLaunch++;
        }
        
        uint256 tax = 0;

        if (isSell) {
            consecutiveSells++;
            consecutiveBuys = 0;
            if (consecutiveSells >= 3) {
                sellTax = 50;
            }
        } else if (isBuy && amount >= 1000 * 10 ** uint256(decimals)) {
            consecutiveBuys++;
            consecutiveSells = 0;
            if (consecutiveBuys >= 3) {
                buyTax = finalTax;
                sellTax = finalTax;
            }
        }

        if (block.timestamp - launchTime <= 2 minutes) {
            tax = isBuy ? buyTax : sellTax;
        } else {
            tax = finalTax;
        }

        uint256 taxAmount = (amount * tax) / 100;
        uint256 amountAfterTax = amount - taxAmount;

        _transfer(msg.sender, owner, taxAmount);
        _transfer(msg.sender, recipient, amountAfterTax);

        return true;
    }

    function allowance(address _owner, address spender) public view override returns (uint256) {
        return _allowances[_owner][spender];
    }
    
    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }
    
    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");
        require(_balances[sender] >= amount, "ERC20: insufficient balance");
        
        _balances[sender] -= amount;
        _balances[recipient] += amount;
        
        emit Transfer(sender, recipient, amount);
    }
    
    function _approve(address _owner, address spender, uint256 amount) internal {
        require(_owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");
        
        _allowances[_owner][spender] = amount;
        
    }

    function emergencyWithdraw() external {
        require(msg.sender == owner, "Only the owner can withdraw");
        payable(owner).transfer(address(this).balance);
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}